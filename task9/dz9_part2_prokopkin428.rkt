#lang scheme
(require racket/class)

(define 2tree<%> (interface () isEmpty? printTree))

(define Empty2tree%
  (class* object% (2tree<%>)
    (super-new)
    (define/public (isEmpty?) #t)
    (define/public (printTree) (void))
    )
  )

(define Nonempty2tree%
  (class* object% (2tree<%>)
    (super-new)
    (init-field tag data (left (new Empty2tree%)) (right (new Empty2tree%)))
    (define/public (isEmpty?) #f)
    (define/public (printTree)
      (begin
        (send (send this get-right) printTree)
        (display tag)
        (display " ")
        (send (send this get-left) printTree)
        )
      )
    (define/public (get-tag) tag)
    (define/public (set-tag! t)
      (set! tag t))
    (define/public (get-data) data)
    (define/public (set-data! d)
      (set! data d))
    (define/public (get-left) left)
    (define/public (set-left! tr)
      (if (or (is-a? tr Nonempty2tree%) (is-a? tr Empty2tree%))
          (set! left tr)
          (error "Wrong type in set-left!")
          )
      )
    (define/public (get-right) right)
    (define/public (set-right! tr)
      (if (or (is-a? tr Nonempty2tree%) (is-a? tr Empty2tree%))
          (set! right tr)
          (error "Wrong type in set-right!")
          )
      )
    )
  )


; Пример
(define a (new Nonempty2tree% (tag 428) (data "data1")))
(define b (new Nonempty2tree% (tag 429) (data "data2"))) 
(define c (new Nonempty2tree% (tag 430) (data "data3")))
(define d (new Nonempty2tree% (tag 431) (data "data4")))
(send a set-right! b)
(send b set-right! c)
(send a set-left! d)
(send a printTree)     